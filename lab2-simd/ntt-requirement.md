# 并行进阶要求选题–多项式乘法及其NTT优化
## 1. 选题背景
多项式乘法作为基础的数学运算，在信号处理、计算机图形学、密码学等领域有着广泛的应用。在该并行选题中，重点关注同态加密中的多项式乘法。同态加密可以在密文上进行运算，对运算后的密文进行解密的结果等于明文直接运算的结果，这在安全领域中是非常重要的技术，而同态加密的其中一项关键组成部分便是多项式乘法。
## 2. 问题定义
在本次选题中，不需要关注同态加密的复杂数学原理，而只关注其中的多项式乘法部分及其NTT优化。
### 2.1 FFT和IFFT
设\(\omega_{n}^{k}=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}\)（下文简称u）。

设矩阵\(W\)（大小为\(n * n\)）为：
\[
\begin{bmatrix}
1 & 1 & 1 & 1 & \cdots & 1 & \cdots & 1 & \cdots & \cdots & 1 \\
1 & \omega & \omega^{2} & \omega^{3} & \cdots & \omega^{4} & \cdots & \cdots & \omega^{n - 1} \\
1 & \omega^{2} & \omega^{4} & \omega^{6} & \cdots & \omega^{8} & \cdots & \cdots & \omega^{2(n - 1)} \\
\cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots \\
\cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \omega^{(n - 1)(n - 1)}
\end{bmatrix}
\]

化简后的矩阵\(W\)为：
\[
\begin{bmatrix}
1 & 1 & 1 & 1 & \cdots & \cdots & \cdots & 1 \\
1 & \omega^{1} & \omega^{2} & \omega^{3} & \cdots & \cdots & \cdots & \omega^{n - 1} \\
1 & \omega^{2} & \omega^{4} & \omega^{6} & \cdots & \cdots & \cdots & \omega^{n - 2} \\
\cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots \\
1 & \omega^{n - 1} & \omega^{n - 2} & \omega^{n - 3} & \cdots & \cdots & \cdots & \omega
\end{bmatrix}
\]

假定\(n\)维向量\(X = [x_{0}, x_{1}, \cdots, x_{n - 1}]^{T}\)，则向量\(X\)的傅里叶变换为\(Y = WX\)。使用矩阵 - 向量乘法可以在\(\Theta(n^{2})\)的时间复杂度内计算出结果，但实际上可以使用分治算法在\(\Theta(nlogn)\)的时间复杂度内求解。设\(n\)为2的次幂，若实际求解中\(n\)不是2的次幂，可以对向量进行补0扩充至2的次幂。设矩阵\(W\)的第\(i\)行，第\(j\)列（设最上面一行为第0行，最左边一列为第0列）的值为\(W(i, j)\)，则\(W\)具有如下性质：
1. 当\(i\)为偶数且\(0\leq i\leq n - 1\)时，\(W(i, j)=W(i, n / 2 + j)(0\leq j\leq n / 2)\)
2. 当\(i\)为奇数且\(0\leq i\leq n - 1\)时，\(W(i, j)= - W(i, n / 2 + j)(0\leq j\leq n / 2)\)。

所以当计算\(Y = WX\)时，有如下结论：
1. 当\(i\)为偶数且\(0\leq i\leq n - 1\)时，\(y_{i}=\sum_{j = 0}^{n / 2 - 1}W(i, j)(x_{j}+x_{j + n / 2})\)
2. 当\(i\)为奇数且\(0\leq i\leq n - 1\)时，\(y_{i}=\sum_{j = 0}^{n / 2 - 1}W(i, j)(x_{j}-x_{j + n / 2})\)。

所以向量\([y_{0}, y_{2}, y_{4} \cdots, y_{n - 2}]\)是向量\([x_{0}+x_{n / 2}, x_{1}+x_{n / 2 + 1}, \cdots, x_{n / 2 - 1}+x_{n - 1}]\)的傅里叶变换；向量\([y_{1}, y_{3}, y_{5} \cdots, y_{n - 1}]\)是向量\([x_{0}-x_{n / 2}, \omega(x_{1}-x_{n / 2 + 1}), \cdots, \omega^{n / 2 - 1}(x_{n / 2 - 1}-x_{n - 1})]\)的傅里叶变换。由上述两式即可得到向量\(Y = [y_{0}, y_{1}, y_{2}, \cdots, y_{n - 1}]\)，\(Y\)即为\(x\)的傅里叶变换。

又当\(n = 2\)时，向量\([x_{0}, x_{1}]\)的傅里叶变换直接等于向量\([x_{0}+x_{1}, x_{0}-x_{1}]\) 。所以向量\(x\)的傅里叶变换可以利用分治算法求解。

傅里叶逆变换即已知傅里叶变换的结果\(Y = [y_{0}, y_{1}, y_{2} \cdots, y_{n - 1}]\)，求原始向量\(X = [x_{0}, x_{1}, \cdots, x_{n - 1}]\)，即求解矩阵\(W\)的逆矩阵\(W^{-1}\)。经过推导可得\(W^{-1}\)为\(\frac{1}{\alpha}[\begin{array}{cccc}1 & 1 &... & 1 1 & (\omega^{n - 1})^{2} & (\omega^{n - 2})^{2} & \cdots & (\omega^{n - 1})^{n - 1} 1 & (\omega^{n - 2})^{2} & (\omega^{n - 3})^{2} & \cdots & (\omega^{n - 2})^{n - 1} \vdots & \vdots & \vdots & \ddots & \vdots 1 & (\omega^{n})^{2} & (\omega^{n})^{2} & \cdots & (\omega^{n})^{2}\end{array}]\)
### 2.2 运用FFT加速多项式乘法
给定多项式\(f(x)=a_{n - 1}x^{n - 1}+...+a_{1}x + a_{0}\)和其系数组成的向量\(X_{f}=[a_{0}, a_{1},... a_{n - 1}]^{T}\)，对向量\(X_{f}\)进行傅里叶变换可以得到\(Y_{f}=[A_{0}, A_{1},..., A_{n - 1}]\)，有傅里叶变换的矩阵向量乘法定义可知，\(A_{k}=f(w^{k})\)。同时知道\(n\)点可以唯一确定一个\(n - 1\)次的多项式，那么在FFT之后，已经有了\((w^{0}, f(w^{0})), \cdots,(w^{n - 1}, f(w^{n - 1}))\)这\(n\)个点。同理，对应多项式\(g(x)\)，也可以得到\((w^{0}, g(w^{0})), \cdots,(w^{n - 1}, g(w^{n - 1}))\)这\(n\)个点，那么可以得到\((w^{0}, f(w^{0})g(w^{0})), \cdots,(w^{n - 1}, f(w^{n - 1})g(w^{n - 1}))\)，而这实际上是多项式乘法结果\(h(x)\)上的\(n\)个点，那么只要对这\(n\)个点做一次快速傅里叶逆变换即可得到多项式\(h(x)\)的各项系数。
### 2.3 NTT
FFT利用了复数单位根的特殊性质来对傅里叶变换进行优化，但存在着浮点误差，浮点计算量大等问题。而NTT通过了拥有与复数单位根相同性质的另一数学工具来避免了浮点运算（使用\(Z_{p}\)上的单位根来代替复数单位根）。首先介绍\(Z_{p}\)（\(P\)为质数）的性质：\(Z_{p}=0,1,2, \cdots, p - 1\)，对于\(a, b \in Z_{p}\)，两数的加法结果为\((a + b) \bmod p\)，减法、乘法和加法同理。\(Z_{p}\)上同样可以进行除法，设\(a\)，\(b\)除法结果为\(x\)，则\(x\)满足\(a \equiv bx(\bmod p)\)，\(x\)的求解可以通过费马小定理来完成。
## 3. 算法简介
和FFT的处理思路一样，令\(n\)为2的次幂，但在NTT中，还需要\(n|(p - 1)\)（这可以通过选择一个合适的\(p\)来完成）。令\(g\)为\(p\)的一个原根，则\(Z_{p}\)上的单位根定义为：\(g_{n}=g^{\frac{p - 1}{n}}\)。

容易证明，\(g_{n}\)和单位根\(w_{n}\)具有相同的性质，所以将之前FFT中所有的\(w_{n}\)换成\(g_{n}\)，将所有复数运算换成有限域上的运算即为NTT。

NTT朴素的实现方式分为递归和迭代两种，其中迭代运行需要使用蝶形变换进行预处理。目前均是在迭代实现上做并行优化，建议重点在迭代实现的NTT上进行优化。
### 3.1 SIMD
朴素的SIMD优化即对蝶形运算过程中的加法和减法进行向量化。NTT中的一个耗时非常长的操作为模乘操作，由于朴素的模乘无法利用SIMD进行优化，所以介绍一个模乘的优化算法：Montgomery模乘。Montgomery模乘的主体思想是选择一个有关模数的参数\(r\)，使得计算\(a ×b ×r^{-1} \bmod p\)这个操作可以通过一系列加减乘法和位运算来替换掉原本的取模运算。

同时可以考虑更多的NTT优化，例如四分NTT等可以更好利用SIMD特性的NTT算法，也可探索其他的模乘算法。同时可以根据模数大小设计不同的NTT优化算法，例如模数可以用16位无符号整型存下时可以更好地利用SIMD指令的特性。
### 3.2 pthread/openmp
由于蝶形运算之间互相独立，朴素的多线程优化为在分治过程中将蝶形运算平均划分到各线程中去，每个线程负责一部分运算。

在同态加密场景中，有可能模数的长度非常大，无法直接进行运算。此时往往通过将模数拆解为多个小模数，在每个小模数上分别进行NTT，最后再将每个小模数上的结果通过中国剩余定理合并，可以尝试对该场景下的NTT进行并行化，也可以自行调研一些NTT多线程优化相关论文然后进行实现。
### 3.3 MPI
MPI与多线程的优化思路基本一致，可以仿照多线程的思路进行，也可自行查阅资料探索更多的内容。
### 3.4 GPU
GPU优化可以采用和多线程类似的思路进行，也可以自行调研一些专门针对GPU优化的NTT算法。

另外由于NTT本质上还是矩阵向量乘法，可以尝试使用GPU对暴力矩阵乘法进行优化。
### 3.5 期末报告
1. 在之前实验基础上探索更多的NTT优化算法。
2. 将之前的实验和代码整理完善，形成一个完整的工作。
3. 对比不同并行环境下不同算法的性能。
## 4. 代码框架说明
### 4.1 代码测试
测试方法类似ann的测试，脚本使用、文件输入输出方法相同，注意多项式乘法的最终结果不需要输出，正确性可以通过函数fCheck判断。如果需要查看中间结果或最终结果，可以调用函数fWrite写入文件，禁止调用std::cout输出大量调试信息。

提交测试，第一个参数为作业编号，SIMD - 1，pthread/openmp - 2，mpi - 3：bash test.sh 1 1
### 4.2 数据说明
保证输入的所有模数的原根均为3，且模数都能表示为\(a ×4^{k}+1\)的形式。不同输入文件只有输入模数不同，输入模数分别为7340033、104857601、469762049、1337006139375617。其中，第四个模数超过了整型表示范围，如果实现此模数意义下的多项式乘法需要略微修改框架，对第四个模数的输入数据不做必要要求，如果要自行探索大模数NTT，请在完成前三个模数的基础代码及优化后实现大模数NTT（目前的同态加密中经常会出现较大模数）。

输入文件共五个，第一个输入文件\(n = 4\)，其余四个文件分别对应四个模数\(n = 131072\)。在实现快速数论变化前，后四个测试样例运行时间较久，推荐调试正确性时只使用输入文件0。
### 4.3 框架内容
框架里只给出了多项式乘法的朴素算法，需要先自行实现快速数论变化（NTT）代替原有的多项式乘法。

本选题基础要求即实现多项式乘法朴素算法的并行化算法，进阶要求即实现NTT的并行化要求。

框架代码只要求正确性测试、数据读取函数和计时方法不允许更改，其余代码仅供参考，最终测试会测试五个输入。

如果在实验报告中进行性能对比，需要保存一份多项式乘法朴素算法的运行结果（运行时间较长脚本可能会自动截断，推荐每个模数单独测试）。 