4 体系结构相关实验分析——矩阵与向量内积
4.1 实验介绍
给定一个 n×n 矩阵，计算每一列与给定向量的内积，考虑两种算法设计思路：逐列访问元素的平凡算法和 cache 优化算法，进行实验对比：
1.	对两种思路的算法编程实现；
2.	练习使用高精度计时测试程序执行时间，比较平凡算法和优化算法的性能。
4.2 实验设计指导
4.2.1 题目分析
本题与讲义中矩阵列求和的例子非常相似，都是关于如何设计算法，令访存模式具有更好的空间局部性，从而发挥 cache 的能力。
平凡算法逐列访问矩阵元素，一步外层循环（内存循环一次完整执行）计算出一个内积结果；cache 优化算法则改为逐行访问矩阵元素，一步外层循环计算不出任何一个内积，只是向每个内积累加一个乘法结果。后者的访存模式具有很好空间局部性，令 cache 的作用得以发挥。
需要注意以下几点：
1.	实验设计（问题规模的确定、测试数据的生成等）
对于本问题，测试数据人为设定固定值即可，例如 A[i][j] = i + j，方便程序正确性检查。对本题而言，程序性能与 cache 相关，而现代 CPU cache 有多个层次，每个层次有固定规模（结合体系结构调研作业）。因此，观察问题规模与 cache 大小不同关系时的程序性能变化，是有意义的。性能测试中可设置一系列不同的问题规模，规模可对应于实验 CPU 设备各级 cache 大小，以研究问题规模变化对程序性能产生的影响及变化趋势。并且，我们可以创建一定大小的数组来占据内存空间，来进一步观察更小的内存对程序性能产生的影响。
2.	程序分析
一方面，可对算法进行理论分析（包括程序性能随问题规模变化的趋势，以及问题达到与各级 cache 大小相对应规模时程序性能变化等），计算时间复杂度及空间复杂度。此外，这里除了考虑基本的计算次数外，还需额外考虑程序的访存开销。
另一方面，可采用 VTune 等工具获取程序运行时一些系统层面的指标（如 cache 命中率、缺页次数等），揭示性能表现的内在原因，同时也可与理论分析对照。VTune 的使用见 6节。
3.	程序测试（运行时间测量）
参考《实验教学指导书-Lab0》中的程序运行时间测量方法。由于本问题计算较为简单，当矩阵规模较小时，程序运行时间很短。因此，可采用重复运行待测函数、延长计时间隔的方法，来解决计时函数精度不够、影响测量精度的问题。
4.2.2 算法设计与编程
编程思路与讲义中矩阵列求和的例子几乎一致：
•	平凡算法
 	
// 逐列访问矩阵元素：一步外层循环（内存循环一次完整执行）计算出一个内积结果 for(i = 0; i < n; i++){ sum[i] = 0.0;
for(j = 0; j < n; j++)

4.3 程序编译和运行
}	sum[i] += b[j][i] ∗ a[j ];
5
6
•	优化算法
// 改为逐行访问矩阵元素：一步外层循环计算不出任何一个内积，只是向每个内积累加一个乘法结果 for(i = 0; i < n; i++) sum[i] = 0.0; for(j = 0; j < n; j++) for(i = 0; i < n; i++)
sum[i] += b[j][i] ∗ a[j ];
1
2
3
4
5
6
后者的访存模式与行主存储匹配，具有很好空间局部性，令 cache 作用得以发挥。
4.3 程序编译和运行
程序的编译、运行和结果查看可参考《实验教学指导书-Lab0》。在本实验中，我们都是进行本地并行编程练习，不涉及华为鲲鹏服务器。
5 体系结构相关实验分析——n个数求和
5.1 实验介绍
计算 n 个数的和，考虑两种算法设计思路：逐个累加的平凡算法（链式）；适合超标量架构的指令级并行算法（相邻指令无依赖），如最简单的两路链式累加，再如递归算法——两两相加、中间结果再两两相加，依次类推，直至只剩下最终结果。完成如下作业：
1.	对两种算法思路编程实现；
2.	练习使用高精度计时测试程序执行时间，比较平凡算法和优化算法的性能。
5.2 实验设计指导
5.2.1 题目分析
本题需要关注以下几点：
1.	测试数据的生成。同上一个题目一样，数据生成人为指定即可，元素个数 n 取 2 的幂即可，方便递归算法设计。
2.	循环处理。几个算法基本实现方式都是采用循环，但可能带来严重的额外开销——每个元素只进行一次加法，但却需要进行循环判定、归纳变量递增等多个额外操作。可采用循环展开（unroll）策略 ——每个循环步进行多次加法运算，相当于将多个循环步的工作展开到一个循环步，从而大幅度降低簿记操作的比例。甚至可以采用宏/模板将循环完全去掉。但要注意，不同算法尽量保持相同的展开比例，保证性能对比的公平性。循环展开可结合指令级并行，即，合并到一个循环步中的多个计算通过合理设计令它们相互不依赖，可同时由多条流水线处理。
3.	中间结果处理。递归算法每个步骤会得到大量中间结果，可在输入数组中原地保存（输入的元素不再被使用的话），也可分配一个辅助数组保存。元素访问顺序要小心设计，注意空间局部性。
4.	问题规模（元素个数）设置。同样可考虑流水线条数、cache 大小等系统参数来设置实验中的问题规模。
5.	较小问题规模执行。当问题规模较小时执行时间可能很短，可将核心计算重复多次，以提高性能测试和 profiling 的精度，如上一题。
5.3 程序编译、运行、结果分析及更多思考
5.2.2 算法设计与编程
•	平凡算法
// 链式：将给定元素依次累加到结果变量即可 for (i = 0; i < n; i++) sum += a[i];
1
2
3
•	优化算法
// 多链路式
sum1 = 0; sum2 = 0
for (i = 0；i < n; i += 2) { sum1 += a[i]; sum2 += a[i + 1];
}
sum = sum1 + sum2;
// 递归：
1. 将给定元素两两相加，得到n/2个中间结果; 2. 将上一步得到的中间结果两两相加，得到n/4个中间结果;
3. 依此类推，log(n)个步骤后得到一个值即为最终结果。
// 实现方式1：递归函数，优点是简单，缺点是递归函数调用开销较大 function recursion(n)
{
if (n == 1) return;
else
{
for (i = 0; i < n / 2; i++) a[i] += a[n − i − 1];
n = n / 2;
recursion(n);
}
}
// 实现方式2：二重循环 for (m = n; m > 1; m /= 2) // log(n)个步骤 for (i = 0; i < m / 2; i++) a[i] = a[i ∗ 2] + a[i ∗ 2 + 1] // 相邻元素相加连续存储到数组最前面
// a[0]为最终结果
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31 32
5.3 程序编译、运行、结果分析及更多思考
一个可以探索的问题，如果是进行浮点运算，计算次序的改变可能会导致结果变化（计算机表示浮点数精度有限导致），而本问题的指令级并行算法与串行算法中元素累加顺序是不同的，可对此进行探索。
